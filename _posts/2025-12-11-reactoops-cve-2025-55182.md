---
title: "ReactOOPS â€“ Exploiting CVE-2025-55182 in a Realistic Next.js Environment"
date: 2025-12-11 15:55:00 +0530
categories: [HackTheBox, Web Security, CVE Analysis]
tags: [Next.js, React, RSC, CVE-2025-55182, HTB, Vulnerability Research]
description: "A deep technical walkthrough of how I solved the ReactOOPS HackTheBox challenge using CVE-2025-55182, including fingerprinting, recon, exploitation workflow, and lessons learned."
---

# ğŸ¯ Introduction
The **ReactOOPS** challenge on HackTheBox is a perfect real-world simulation of the devastating **CVE-2025-55182** vulnerability affecting **React Server Components (RSC)** in Next.js.

This wasnâ€™t a simple â€œrun the scriptâ€ challenge.  
It required **framework fingerprinting**, **endpoint analysis**, and **controlled exploitation**.

In this write-up, Iâ€™ll walk through:

- How I approached the challenge  
- How I identified that the target uses RSC  
- Why version detection matters  
- How CVE-2025-55182 works in practice  
- And finally, how I gained code execution and retrieved the flag  

This post contains **no harmful payloads** â€” only methodology.

---

# ğŸ” Step 1 â€” Initial Access & Application Recon

Once the machine spawned, I loaded the target IP:

![screenshot](/assets/img/reactoops/home.png)

The landing page presented a clean **Next.js SaaS-style UI**.

Nothing malicious stood out visually, but security assessments never start with the UI â€” they start with **the framework**.

---

# ğŸ” Step 2 â€” Checking the JavaScript Source for RSC Clues

I opened **DevTools â†’ Sources** and began inspecting the `/\_next/static/` bundles.

While searching inside the JS chunks, I found something very interesting:


![screenshot](/assets/img/reactoops/source.png)

That keyword immediately signals **React Server Components (RSC)**, because:

- The Flight protocol uses specialized request markers  
- RSC actions require server-side deserialization  
- These markers appear only when the App Router is enabled  

**This is the first major signal** that the app is potentially vulnerable.

---

# ğŸ” Step 3 â€” Fingerprinting the Framework Version

Next, I verified the framework version using **Wappalyzer**.

![screenshot](/assets/img/reactoops/wappalyzer.png)

The result:

> **Next.js 16.0.6**

This is important because:

| Next.js Version | Status |
|----------------|--------|
| 16.0.6 | âŒ Vulnerable (shipped with RSC v19.0.0â€“19.2.0) |
| 16.0.7+ | âœ” Patched |

So now we have:

1. **RSC detected**  
2. **Next.js vulnerable version**  
3. **Public-facing server**  

Thatâ€™s enough for a **high-confidence vulnerability match**.

---

# ğŸ”¥ Step 4 â€” Testing for CVE-2025-55182 Exposure

Since the challenge is intentionally vulnerable, I moved to RSC vulnerability validation.

I used the publicly known proof-of-concept tooling (`react2shell-scanner`).

**Targeting the machine:**

![screenshot](/assets/img/reactoops/whoami.png)

The `whoami` command executed successfully, showing:


This confirms:

- The RSC endpoint is reachable  
- The vulnerable React Flight deserialization logic is active  
- Arbitrary server-side code execution is possible  

This is exactly what CVE-2025-55182 is about:  
**deserializing untrusted RSC payloads into server action invocations.**

---

# ğŸ”¥ Step 5 â€” Dropping into Interactive Mode

The tool also provides an â€œinteractive shell.â€

Using the `find` command, I enumerated `.txt` files on the server:

![screenshot](/assets/img/reactoops/find.png)

Inside `/app/`, I found:


Retrieving it:

![screenshot](/assets/img/reactoops/flag.png)

Flag obtained.  
Challenge complete.

---

# ğŸ§  Understanding What Just Happened (Why the Exploit Works)

CVE-2025-55182 exists because **Next.js incorrectly trusts Flight payloads** sent to RSC endpoints.

Flight requests contain serialized objects representing:

- server references  
- component tree values  
- action identifiers  

In vulnerable versions, attackers can:

1. Forge a Flight payload  
2. Redirect the deserializer into resolving crafted references  
3. Trick the server into executing code (often via NodeJS built-in modules)  

Because RSC endpoints are **public**, no authentication is required.

This chain results in:

> **Pre-authentication Remote Code Execution**

Thatâ€™s why the CVSS score is **10.0**.

---

# âœ” Final Thoughts

This challenge is a perfect demonstration of how dangerous modern framework vulnerabilities can be.

Traditional web application testing often focuses on:

- Endpoints  
- Parameters  
- API routes  

But React Server Components introduce an entirely new attack surface:

- A **serialization protocol (Flight)**  
- A hidden **server function execution layer**  
- Framework-driven server logic that developers donâ€™t manually write  

Whenever frameworks take control of server-side behavior, vulnerabilities at the framework level become catastrophic.

---

# ğŸ Summary

| Step | Action |
|------|--------|
| 1 | Viewed the target â†’ UI built with Next.js |
| 2 | Inspected JS bundles â†’ found RSC keywords |
| 3 | Fingerprinted version (16.0.6) â†’ known vulnerable |
| 4 | Used PoC tooling â†’ confirmed RCE |
| 5 | Enumerated filesystem â†’ grabbed flag |

---

If you want, I can generate:

- **A thumbnail banner** for this post  
- **More polished screenshots**  
- **A shorter LinkedIn-ready version**  
- **A YouTube-style script version**  

Just tell me what you want next.
